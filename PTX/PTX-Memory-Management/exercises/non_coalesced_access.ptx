//
// Non-coalesced memory access example
// Demonstrates poor memory access patterns
//

.version 6.0
.target sm_50
.address_size 64

.visible .entry non_coalesced_copy(
    .param .u64 input_ptr,
    .param .u64 output_ptr,
    .param .u32 n,
    .param .u32 stride
) {
    .reg .u32 %tid;
    .reg .u32 %n_val, %stride_val;
    .reg .u64 %input_addr, %output_addr;
    .reg .u64 %input_idx_addr, %output_idx_addr;
    .reg .f32 %value;
    .reg .pred %cond;
    .reg .u32 %global_idx;
    
    // Get thread ID
    mov.u32 %tid, %tid.x;
    
    // Load parameters
    ld.param.u32 %n_val, [n];
    ld.param.u32 %stride_val, [stride];
    ld.param.u64 %input_addr, [input_ptr];
    ld.param.u64 %output_addr, [output_ptr];
    
    // Calculate non-coalesced address (every stride-th element)
    mul.wide.u32 %global_idx, %tid, %stride_val;
    
    // Calculate addresses
    mul.wide.u32 %input_idx_addr, %global_idx, 4;  // 4 bytes per float
    add.u64 %input_idx_addr, %input_addr, %input_idx_addr;
    add.u64 %output_idx_addr, %output_addr, %input_idx_addr;
    
    // Bounds check
    setp.lt.u32 %cond, %global_idx, %n_val;
    
    // Perform non-coalesced copy if within bounds
    @%cond ld.global.f32 %value, [%input_idx_addr];
    @%cond st.global.f32 [%output_idx_addr], %value;
    
    ret;
}